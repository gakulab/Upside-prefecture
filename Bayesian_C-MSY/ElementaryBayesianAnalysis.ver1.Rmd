---
title: "Elementary Bayesian Analysis"
author: "keikawamura"
date: "4/6/2021"
output: html_document
---
Catch-MSYのアプローチをわかりやすくし、ベイズ推論とどう対応しているか関係性を確認する

# 基本設定

```{r setup, include=FALSE}y

#環境の初期化
rm(list = ls(all=T))

#ライブラリの読み込み
library(tidyverse)
library(rfishbase)

#パスの指定
path_data <- "/Volumes/GoogleDrive/My Drive/Upside-prefecture/Data_Working"


#データの読み込み
setwd(path_data)
CatchData <- read.csv("CatchJPN1956_2019_enc.csv",stringsAsFactors = F,fileEncoding = "Shift_JIS")


#データクリーニング
#今回は岩手県、マダラ（cod）を選択
CatchData2 <- CatchData %>%
  filter(alphabet == "iwate", fish == "cod") %>%
  select(alphabet,year,fish,catch_t) 


#データを簡単に確認
plot(x = CatchData2$year, y = CatchData2$catch_t, type = "l", main = "Historical Catch of Cod in Iwate")
```

# 準備

```{r}
#Create Date 2021/4/7-

#今回は1魚種(マダラ：cod)に絞って推定を行う。
#しかし、データにレジリエンスが付与されていないのでDanさんに習ってrfishbaseのstocks関数を用いてレジリエンスを取得する。

#stocks関数は学名に準じて各種生物情報を入手するため、学名をデータに付与する。
CatchData2$SciName <- "Gadus macrocephalus"

#stocks関数で生物情報(レジリエンスと種名)を獲得。マダラの場合はresilienceがNAとLOWの２つが出てくるので、na.omit()を追加
res <- as.character(na.omit(stocks(CatchData2$SciName[1],fields = "Resilience"))) #fieldsオプションはreturnする列の指定を行う

#再現性を優先し、乱数を固定
set.seed(999)  ## for same random sequence

#パラメタ設定のための準備
yr   <- CatchData2$year
ct   <- as.numeric(CatchData2$catch_t)/1000  ## 単位を1000トンに変更
nyr  <- length(yr)    ## number of years in the time series
  
```


# パラメータ

```{r}  
###  r  ###
# レジリエンスからr（内的自然増加率）の範囲を大まかに設定（rにおける事前情報）
start_r  <- if(res == "Very low"){c(0.015, 0.1)}else if(res == "Low") {c(0.05,0.5)}else if(res == "High") {c(0.6,1.5)}else {c(0.2,1)}

###  K  ###
start_k     <- c(max(ct),50*max(ct)) 

###  B0  ###
#r,kとは違って、startbio(B/K)の範囲を漁獲量から規定し、Kを掛けて初期資源量を算出する。初期資源量の算出は分析時に行う
startbio    <- if(ct[1]/max(ct) < 0.5) {c(0.5,0.9)} else {c(0.3,0.6)} 

#パラメータセットの作成
size <- 10000

#parameters <- data.frame(
#  ri = rep(runif(size,start_r[1],start_r[2]),10),#start_r[1]~start_r[2]からsize個無作為に抽出した値を10個複製。startbtが10等分なので、それぞれに合うようにした
#  ki = rep(runif(size,start_k[1],start_k[2]),10),
#  startbt = rep(seq(startbio[1],startbio[2],length = 10),each = size)) %>%
#  mutate(
#  b0 = startbt * ki
#  )


```

# モデル準備

```{r}

  interyr 	<- yr[nyr/2]
  #interbioはr-kのペアの採択条件になるが、0~1なので絞り込みとしては機能してい無い。
  interbio 	<- c(0, 1) ## biomass range for interim year, as fraction of k; set to 0 and 1 if not available
  ## finalbio 	<- c(0.8, 0.9) ## biomass range after last catches, as fraction of k
  #finalbioはr-kのペアの採択条件になる。以下の数字の根拠は別論文に記載。
  finalbio    <- if(ct[nyr]/max(ct) > 0.5) {c(0.3,0.7)} else {c(0.01,0.4)} ## use for batch processing
  n           <- 30000  ## number of iterations, e.g. 100000
  sigR        <- 0.0      ## process error; 0 if deterministic model; 0.05 reasonable value? 0.2 is too high
  
  #Upsideでは10等分であった
  startbt     <- seq(startbio[1], startbio[2], by = 0.05) ## apply range of start biomass in steps of 0.05	
  
  #パラメータリストを作成
  parbound <- list(r = start_r,
                   k = start_k,
                   lambda = finalbio,
                   sigR)
  
  #基本情報を表示
  cat("Last year =",max(yr),", last catch =",1000*ct[nyr],"(unit:1000tonnes)","\n",
      "Resilience =",res,"\n",
      "Process error =", sigR,"\n",
      "Assumed initial biomass (B/k) =", startbio[1],"-", startbio[2], " k","\n",
      "Assumed intermediate biomass (B/k) in", interyr, " =", interbio[1],"-",interbio[2]," k","\n",
      "Assumed final biomass (B/k) =", parbound$lambda[1],"-",parbound$lambda[2]," k","\n",
      "Initial bounds for r =", parbound$r[1], "-", parbound$r[2],"\n",
      "Initial bounds for k =", format(1000*parbound$k[1], digits=3), "-", format(1000*parbound$k[2],digits=3),"\n"
      )
  
  flush.console()
  
```

# FUNCTIONS

```{r}
  sraMSY	<-function(theta, N)
  {
    #This function conducts the stock reduction
    #analysis for N trials
    #args:
    #	theta - a list object containing:
    #		r (lower and upper bounds for r)
    #		k (lower and upper bounds for k)
    #		lambda (limits for current depletion)
    
    
    with(as.list(theta), 
         {
           ri = exp(runif(N, log(r[1]), log(r[2])))  ## get N values between r[1] and r[2], assign to ri
           #rii = runif(N, r[1], r[2])
           ki = exp(runif(N, log(k[1]), log(k[2])))  ## get N values between k[1] and k[2], assing to ki
           #kii = runif(N, k[1], k[2])
           #itheta=cbind(r=ri,k=ki, lam1=lambda[1],lam2=lambda[2], sigR=sigR) ## assign ri, ki, and final biomass range to itheta
           itheta=cbind(r=ri,k=ki, lam1=lambda[1],lam2=lambda[2], sigR=sigR)
           M = apply(itheta,1,.schaefer) ## call Schaefer function with parameters in itheta
           i=1:N
           ## prototype objective function
           get.ell=function(i) M[[i]]$ell
           ell = sapply(i, get.ell) 
           return(list(r=ri,k=ki, ell=ell))	
         })
  }
  
  #SPM
  .schaefer	<- function(theta)　#thetaはパラメタセットが入る
  {
    with(as.list(theta), {  ## for all combinations of ri & ki
      bt=vector()
      ell = 0  ## initialize ell
      for (j in startbt)
      {
        if(ell == 0) 
        {
          bt[1]=j*k*exp(rnorm(1,0, sigR))  ## set biomass in first year
          for(i in 1:nyr) ## for all years in the time series
          {
            xt=rnorm(1,0, sigR)
            bt[i+1]=(bt[i]+r*bt[i]*(1-bt[i]/k)-ct[i])*exp(xt) ## calculate biomass as function of previous year's biomass plus net production minus catch
          }
          
          #Upsideであった不明な条件(startbtが最小のものにする)が無い
          #Bernoulli likelihood, assign 0 or 1 to each combination of r and k
          ell = 0
          if(bt[nyr+1]/k>=lam1 &&
             bt[nyr+1]/k <=lam2 &&
             min(bt) > 0 &&
             max(bt) <=k &&
             bt[which(yr==interyr)]/k>=interbio[1] &&
             bt[which(yr==interyr)]/k<=interbio[2]) 
            ell = 1
        }	
      }
      return(list(ell=ell))
      
      
    })
  }
  
  
  
  ## MAIN
  R1 = sraMSY(parbound, n) #r,kのサンプリング方法が対数を使用（Catch-MSYではデフォルト）
  R2 = sraMSY(parbound, n) #サンプリング部分を手動で変更！！
 
  #パラメータのサンプリング確認用
  r = start_r
  k = start_k
  N = n
  ri = exp(runif(N, log(r[1]), log(r[2])))  ## get N values between r[1] and r[2], assign to ri
  ki = exp(runif(N, log(k[1]), log(k[2])))  ## get N values between k[1] and k[2], assing to ki
  rii = runif(N, r[1], r[2])
  kii = runif(N, k[1], k[2])

  
## Get statistics on r, k, MSY and determine new bounds for r and k
  #ell==1は条件を満たすという意味である
  r1 	<- R1$r[R1$ell==1]
  k1 	<- R1$k[R1$ell==1]
  length(unique(r1)) #1873
  
  r2 	<- R2$r[R2$ell==1]
  k2 	<- R2$k[R2$ell==1]
  length(unique(r2)) #896
  
#plot section 
  plot(density(ri),xlim=c(0.05,0.5))
  plot(density(rii),xlim=c(0.05,0.5))
  
  plot(density(r1),xlim=c(0.05,0.5))
  plot(density(r2),xlim=c(0.05,0.5))
  
  plot(density(ki),xlim=c(k[1],k[2]))
  plot(density(kii),xlim=c(k[1],k[2]))
  
  plot(density(k1),xlim=c(k[1],k[2]))
  plot(density(k2),xlim=c(k[1],k[2]))
  
  ggplot(data.frame(R1),aes(x = r, y = k,col = factor(ell)))+
    geom_point()
  ggplot(data.frame(R2),aes(x = r, y = k,col = factor(ell)))+
    geom_point()
  

#対数の確認
  test <- data.frame(
    num = 1:100,
    r = seq(r[1],r[2],length=100),
    log_r = seq(log(r[1]),log(r[2]),length=100)) %>%
    mutate(true_r = exp(log_r))
  
  plot(test$num,test$r,type="l",col = "red")
  par(new = T)
  plot(test$num,test$true_r,type = "l",col="blue")

```
    
# 決定論的なSPMを確率モデルへ
採択されるパラメータが増える見込み

```{r}
#SPM
  .schaefer_stchastic	<- function(theta)　#thetaはパラメタセットが入る
  {
    with(as.list(theta), {  ## for all combinations of ri & ki
      bt=vector()
      sigR = 0.05 #上の注釈で0.05がreasonable valueと記載されていたから
      ell = 0  ## initialize ell
      for (j in startbt)
      {
        if(ell == 0) 
        {
          bt[1]=j*k*exp(rnorm(1,0, sigR))  ## set biomass in first year
          for(i in 1:nyr) ## for all years in the time series
          {
            xt=rnorm(1,0, sigR)
            bt[i+1]=(bt[i]+r*bt[i]*(1-bt[i]/k)-ct[i])*exp(xt) ## calculate biomass as function of previous year's biomass plus net production minus catch
          }
          
          #Upsideであった不明な条件(startbtが最小のものにする)が無い
          #Bernoulli likelihood, assign 0 or 1 to each combination of r and k
          ell = 0
          if(bt[nyr+1]/k>=lam1 &&
             bt[nyr+1]/k <=lam2 &&
             min(bt) > 0 &&
             max(bt) <=k &&
             bt[which(yr==interyr)]/k>=interbio[1] &&
             bt[which(yr==interyr)]/k<=interbio[2]) 
            ell = 1
        }	
      }
      return(list(ell=ell))
      
      
    })
  }

  sraMSY_stochastic	<-function(theta, N)
  {
    #This function conducts the stock reduction
    #analysis for N trials
    #args:
    #	theta - a list object containing:
    #		r (lower and upper bounds for r)
    #		k (lower and upper bounds for k)
    #		lambda (limits for current depletion)
    
    
    with(as.list(theta), 
         {
           #ri = exp(runif(N, log(r[1]), log(r[2])))  ## get N values between r[1] and r[2], assign to ri
           rii = runif(N, r[1], r[2])
           #ki = exp(runif(N, log(k[1]), log(k[2])))  ## get N values between k[1] and k[2], assing to ki
           kii = runif(N, k[1], k[2])
           #itheta=cbind(r=ri,k=ki, lam1=lambda[1],lam2=lambda[2], sigR=sigR) ## assign ri, ki, and final biomass range to itheta
           #itheta=cbind(r=ri,k=ki, lam1=lambda[1],lam2=lambda[2], sigR=sigR)
           itheta=cbind(r=rii,k=kii, lam1=lambda[1],lam2=lambda[2], sigR=sigR)
           M = apply(itheta,1,.schaefer_stchastic) ## call Schaefer function with parameters in itheta
           i=1:N
           ## prototype objective function
           get.ell=function(i) M[[i]]$ell
           ell = sapply(i, get.ell) 
           return(list(r=rii,k=kii, ell=ell))	
         })
  }
  
  ## MAIN
  R1_s = sraMSY_stochastic(parbound, n) #r,kのサンプリング方法が対数を使用（Catch-MSYではデフォルト）
  R2_s = sraMSY_stochastic(parbound, n) #サンプリング部分を手動で変更！！

  
## Get statistics on r, k, MSY and determine new bounds for r and k
  #ell==1は条件を満たすという意味である
  r1_s 	<- R1_s$r[R1_s$ell==1]
  k1_s 	<- R1_s$k[R1_s$ell==1]
  length(unique(r1_s)) #1873
  
  r2_s 	<- R2_s$r[R2_s$ell==1]
  k2_s 	<- R2_s$k[R2_s$ell==1]
  length(unique(r2_s)) #849

```  

# Plot section 

```{r}
  plot(density(ri),xlim=c(0.05,0.5)) #rのサンプリング(log)
  plot(density(rii),xlim=c(0.05,0.5)) #rのサンプリング
  
  plot(density(r1_s),xlim=c(0.05,0.5)) #ell=1のr(logサンプリング)
  plot(density(r2_s),xlim=c(0.05,0.5)) #ell=1のr
  
  plot(density(ki),xlim=c(k[1],k[2])) #kのサンプリング(log)
  plot(density(kii),xlim=c(k[1],k[2])) #kのサンプリング
  
  plot(density(k1_s),xlim=c(k[1],k[2])) #ell=1のk(logサンプリング)
  plot(density(k2_s),xlim=c(k[1],k[2])) #ell=1のk
  
  #r-kペアの図子
  ggplot(data.frame(R1_s),aes(x = r, y = k,col = factor(ell)))+
    geom_point()
  ggplot(data.frame(R2_s),aes(x = r, y = k,col = factor(ell)))+
    geom_point()
  
  
  #ell=1の結果が埋もれてわかりにくいので単体で表現
  #決定論
  R1_ell <- data.frame(R1) %>%
    filter(ell==1)
  R2_ell <- data.frame(R2) %>%
    filter(ell==1)
  
  #確率
  R1_s_ell <- data.frame(R1_s) %>%
    filter(ell==1)
  R2_s_ell <- data.frame(R2_s) %>%
    filter(ell==1)
  
  ggplot(data.frame(R1_ell),aes(x = r, y = k))+
    geom_point()+
    xlim(r[1],r[2])+
    ylim(k[1],k[2])+
    labs(title = "using log for sampling")
  ggplot(data.frame(R2_ell),aes(x = r, y = k))+
    geom_point()+
    xlim(r[1],r[2])+
    ylim(k[1],k[2])+
    labs(title = "normal sampling")
  ggplot(data.frame(R1_s_ell),aes(x = r, y = k))+
    geom_point()+
    xlim(r[1],r[2])+
    ylim(k[1],k[2])+
    labs(title = "stochastic model & using log for sampling")
  ggplot(data.frame(R2_s_ell),aes(x = r, y = k))+
    geom_point()+
    xlim(r[1],r[2])+
    ylim(k[1],k[2])+
    labs(title = "stochastic model & normal sampling")

  
  #パラメータの分布の変化
  #logを使用
  plot(density(ri),xlim=c(0.05,0.5),main = "prior r log")
  plot(density(r1),xlim=c(0.05,0.5),main = "posterior r log")
  plot(density(r1_s),xlim=c(0.05,0.5),main = "posterior r log stochastic")
  #logを使わない
  plot(density(rii),xlim=c(0.05,0.5),main = "prior r")
  plot(density(r2),xlim=c(0.05,0.5),main = "posterior r")
  plot(density(r2_s),xlim=c(0.05,0.5),main = "posterior r stochastic")
  
#基本的にここ迄はオリジナル通り。手を加えたのは、logを使用しなかったサンプリングによる結果との比較のみである
#次に考えるべきことは、
 #・確率モデルの作り方（sigRの値やランダム変数の場所）
 #・そもそも確率モデルにしたことで精度が向上したのかというモデル評価
 #・各種パラメータの範囲の初期設定値の意味理解

  
```

# あまり

```{r}
  msy1  <- r1*k1/4
  mean_msy1 <- exp(mean(log(msy1))) #幾何平均
  Summary <- cbind(r1,k1,msy1)
  max_k1a  <- min(k1[r1<1.1*parbound$r[1]]) ## smallest k1 near initial lower bound of r
  max_k1b  <- max(k1[r1*k1/4<mean_msy1]) ## largest k1 that gives mean MSY
  max_k1 <- if(max_k1a < max_k1b) {max_k1a} else {max_k1b}
  
  if(length(r1)<10) {
    cat("Too few (", length(r1), ") possible r-k combinations, check input parameters","\n")
    flush.console()
  }
  
  if(length(r1)>=10) {
    
    ## set new upper bound of r to 1.2 max r1
    parbound$r[2] <- 1.2*max(r1)
    ## set new lower bound for k to 0.9 min k1 and upper bound to max_k1 
    parbound$k 	  <- c(0.9 * min(k1), max_k1)
    
    
    cat("First MSY =", format(1000*mean_msy1, digits=3),"\n")
    cat("First r =", format(exp(mean(log(r1))), digits=3),"\n")
    cat("New upper bound for r =", format(parbound$r[2],digits=2),"\n")	
    cat("New range for k =", format(1000*parbound$k[1], digits=3), "-", format(1000*parbound$k[2],digits=3),"\n")
    
    
    ## Repeat analysis with new r-k bounds
    R1 = sraMSY(parbound, n)
    
    ## Get statistics on r, k and msy
    r = R1$r[R1$ell==1]
    k = R1$k[R1$ell==1]
    msy = r * k / 4
    mean_ln_msy = mean(log(msy))
    
    ## plot MSY over catch data
    #A
    par(mfcol=c(2,3))
    plot(yr, ct, type="l", ylim = c(0, max(ct)), xlab = "Year", ylab = "Catch (1000 t)", main = "Stone_Flounder")
    abline(h=exp(mean(log(msy))),col="red", lwd=2)
    abline(h=exp(mean_ln_msy - 2 * sd(log(msy))),col="red")
    abline(h=exp(mean_ln_msy + 2 * sd(log(msy))),col="red")
    
    #D
    hist(r, freq=F, xlim=c(0, 1.2 * max(r)), main = "")
    abline(v=exp(mean(log(r))),col="red",lwd=2)
    abline(v=exp(mean(log(r))-2*sd(log(r))),col="red")
    abline(v=exp(mean(log(r))+2*sd(log(r))),col="red")
    
    #B
    plot(r1, k1, xlim = start_r, ylim = start_k, xlab="r", ylab="k (1000t)")
    #plot(r, k, xlim = start_r, ylim = start_k, xlab="r", ylab="k (1000t)")
    #E
    hist(k, freq=F, xlim=c(0, 1.2 * max(k)), xlab="k (1000t)", main = "")
    abline(v=exp(mean(log(k))),col="red", lwd=2)	
    abline(v=exp(mean(log(k))-2*sd(log(k))),col="red")
    abline(v=exp(mean(log(k))+2*sd(log(k))),col="red")
    
    #C
    plot(log(r), log(k),xlab="ln(r)",ylab="ln(k)")
    abline(v=mean(log(r)))
    abline(h=mean(log(k)))
    abline(mean(log(msy))+log(4),-1, col="red",lwd=2)
    abline(mean(log(msy))-2*sd(log(msy))+log(4),-1, col="red")
    abline(mean(log(msy))+2*sd(log(msy))+log(4),-1, col="red")
    
    #F
    hist(msy, freq=F, xlim=c(0, 1.2 * max(msy)), xlab="MSY (1000t)",main = "")
    abline(v=exp(mean(log(msy))),col="red", lwd=2)
    abline(v=exp(mean_ln_msy - 2 * sd(log(msy))),col="red")
    abline(v=exp(mean_ln_msy + 2 * sd(log(msy))),col="red")
    
    
    cat("Possible combinations = ", length(r),"\n")
    cat("geom. mean r =", format(exp(mean(log(r))),digits=3), "\n")
    cat("r +/- 2 SD =", format(exp(mean(log(r))-2*sd(log(r))),digits=3),"-",format(exp(mean(log(r))+2*sd(log(r))),digits=3), "\n")
    cat("geom. mean k =", format(1000*exp(mean(log(k))),digits=3), "\n")
    cat("k +/- 2 SD =", format(1000*exp(mean(log(k))-2*sd(log(k))),digits=3),"-",format(1000*exp(mean(log(k))+2*sd(log(k))),digits=3), "\n")
    cat("geom. mean MSY =", format(1000*exp(mean(log(msy))),digits=3),"\n")
    cat("MSY +/- 2 SD =", format(1000*exp(mean_ln_msy - 2 * sd(log(msy))),digits=3), "-", format(1000*exp(mean_ln_msy + 2 * sd(log(msy))),digits=3), "\n")
    
    ## Write results into outfile, in append mode (no header in file, existing files will be continued)
    output = data.frame(sigR, startbio[1], startbio[2], interbio[1], interbio[2], finalbio[1], finalbio[2], min(yr), max(yr), res, max(ct), ct[1], ct[nyr], length(r), exp(mean(log(r))), sd(log(r)), min(r), quantile(r,0.05), quantile(r,0.25), median(r), quantile(r,0.75), quantile(r,0.95), max(r), exp(mean(log(k))), sd(log(k)), min(k), quantile(k, 0.05), quantile(k, 0.25), median(k), quantile(k, 0.75), quantile(k, 0.95), max(k), exp(mean(log(msy))), sd(log(msy)), min(msy), quantile(msy, 0.05), quantile(msy, 0.25), median(msy), quantile(msy, 0.75), quantile(msy, 0.95), max(msy)) 
    
    write.table(output, file = outfile, append = TRUE, sep = ";", dec = ".", row.names = FALSE, col.names = FALSE)
    
  }
#}  ## End of stock loop, get next stock or exit
```



















